<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minimal 3D Game</title>
  <style>
    html,body{height:100%;margin:0}
    #hud{position:fixed;top:10px;left:10px;background:#ffffffcc;padding:8px 12px;border-radius:12px;font:14px system-ui}
    #overlay{position:fixed;inset:0;display:none;place-items:center}
    #card{background:#ffffffdd;padding:16px 20px;border-radius:16px;font:16px system-ui;text-align:center}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="hud">Score: <span id="score">0</span> | Time: <span id="time">30</span>s</div>
  <div id="overlay"><div id="card"><div style="font-weight:700;margin-bottom:8px">Time up</div><div>Final score: <span id="final">0</span></div><button id="reset" style="margin-top:12px;padding:8px 12px;border-radius:10px;border:0;background:black;color:white">Play again</button></div></div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Scene + Camera (top-down isometric)
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const camera = new THREE.OrthographicCamera(-6,6,6,-6,0.1,100);
    camera.position.set(8,8,8);
    camera.lookAt(0,0,0);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff,0.6));
    const dir = new THREE.DirectionalLight(0xffffff,1);
    dir.position.set(5,10,5);
    dir.castShadow = true;
    scene.add(dir);

    // Ground (8Ã—8)
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(8,8),
      new THREE.MeshStandardMaterial({color:0x3a3a3a})
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Walls
    const wallMat = new THREE.MeshStandardMaterial({color:0x222222});
    const makeWall = (x,z,ry)=>{
      const m = new THREE.Mesh(new THREE.BoxGeometry(0.1,1,8), wallMat);
      m.position.set(x,0.5,z); m.rotation.y = ry; scene.add(m);
    };
    makeWall(-4,0,0); makeWall(4,0,0); makeWall(0,-4,Math.PI/2); makeWall(0,4,Math.PI/2);

    // Player
    const player = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({metalness:0.1,roughness:0.5}));
    player.position.y = 0.5; player.castShadow = true; scene.add(player);

    // Target
    const targetMat = new THREE.MeshStandardMaterial({emissive:0xffaa00, emissiveIntensity:1});
    const target = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35,0), targetMat);
    target.castShadow = true; scene.add(target);

    function randPos(range=3){return (Math.random()*2-1)*range}
    function placeTarget(){ target.position.set(randPos(), 0.35, randPos()); }
    placeTarget();

    // Input
    const keys = Object.create(null);
    addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
    addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

    let score=0; let timeLeft=30; let running=true; const speed=3;
    const hudScore = document.getElementById('score');
    const hudTime = document.getElementById('time');
    const overlay = document.getElementById('overlay');
    const finalEl = document.getElementById('final');

    function reset(){
      score=0; timeLeft=30; running=true; hudScore.textContent='0'; hudTime.textContent='30';
      player.position.set(0,0.5,0); placeTarget(); overlay.style.display='none';
    }
    document.getElementById('reset').onclick = reset;

    // Timer
    const timer = setInterval(()=>{
      if(!running) return; timeLeft--; hudTime.textContent=String(timeLeft);
      if(timeLeft<=0){ running=false; finalEl.textContent=String(score); overlay.style.display='grid'; }
    },1000);

    // Loop
    let last = performance.now();
    function frame(now){
      const dt = Math.min(0.05,(now-last)/1000); last = now;
      // movement
      if(running){
        let vx=0,vz=0;
        if(keys['w']||keys['arrowup']) vz-=1;
        if(keys['s']||keys['arrowdown']) vz+=1;
        if(keys['a']||keys['arrowleft']) vx-=1;
        if(keys['d']||keys['arrowright']) vx+=1;
        const len = Math.hypot(vx,vz)||1;
        player.position.x = Math.max(-3, Math.min(3, player.position.x + (vx/len)*speed*dt));
        player.position.z = Math.max(-3, Math.min(3, player.position.z + (vz/len)*speed*dt));
        // spin target
        target.rotation.y += dt*2;
        // collect
        const dx = player.position.x - target.position.x;
        const dz = player.position.z - target.position.z;
        if(dx*dx + dz*dz < 0.36){ score++; hudScore.textContent=String(score); placeTarget(); }
      }
      renderer.render(scene,camera);
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Resize
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.left=-6; camera.right=6; camera.top=6; camera.bottom=-6; camera.updateProjectionMatrix();
    });
  </script>
  <noscript>Enable JavaScript.</noscript>
</body>
</html>
